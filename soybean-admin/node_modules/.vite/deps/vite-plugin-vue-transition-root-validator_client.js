import "./chunk-PR4QN5HX.js";

// node_modules/.pnpm/vite-plugin-vue-transition-_29f959dae3f47e153f7b77edb5134830/node_modules/vite-plugin-vue-transition-root-validator/dist/client.js
function formatTransitionRootMessage(lang, ctx) {
  if (lang === "zh") {
    const title$1 = "Vue <Transition> 要求插槽内容具有单一的“元素根节点”。";
    const lines$1 = [];
    lines$1.push(title$1);
    if (ctx.file) lines$1.push(`
文件: ${ctx.file}`);
    if (ctx.url) lines$1.push(`URL: ${ctx.url}`);
    const meta$1 = [];
    if (ctx.component) meta$1.push(`component=${ctx.component}`);
    if (ctx.routeKey) meta$1.push(`key=${ctx.routeKey}`);
    if (meta$1.length) lines$1.push(`上下文: ${meta$1.join(" ")}`);
    lines$1.push(`
如何修复:
- 在${ctx.file ? `文件 ${ctx.file}` : "该组件"}的 <template> 最外层添加一个容器标签（如 <div> / <main>），把所有内容包起来，确保最终只渲染出一个根“标签元素”。
- 根节点不能是多个并列元素（Fragment/多根），也不能是纯文本或注释。
- 如果根部使用了 v-if / v-else，确保每个分支都只渲染一个根标签元素。`);
    lines$1.push("\n为什么会这样:\nVue 的 <Transition> 需要把过渡 class 应用在一个真实的 DOM 元素上；当插槽内容渲染出的根节点不是“单一元素”（例如 Fragment、多根、纯文本或注释）时，就无法执行进入/离开过渡。");
    lines$1.push("\n相关文档:\nhttps://cn.vuejs.org/guide/built-ins/transition#the-transition-component");
    return lines$1.join("\n");
  }
  const title = "Vue <Transition> requires a single element root node in its slot.";
  const lines = [];
  lines.push(title);
  if (ctx.file) lines.push(`
File: ${ctx.file}`);
  if (ctx.url) lines.push(`URL: ${ctx.url}`);
  const meta = [];
  if (ctx.component) meta.push(`component=${ctx.component}`);
  if (ctx.routeKey) meta.push(`key=${ctx.routeKey}`);
  if (meta.length) lines.push(`Context: ${meta.join(" ")}`);
  lines.push(`
How to fix:
- In the <template> of ${ctx.file ? `file ${ctx.file}` : "this component"}, wrap everything with a single container element (e.g. <div> / <main>), so the final render has exactly one root *element*.
- The root cannot be a Fragment (multiple siblings), plain text, or a comment.
- If you use v-if / v-else at the root, ensure each branch renders exactly one root element.`);
  lines.push("\nWhy this happens:\nVue <Transition> needs to apply transition classes to a real DOM element. If the slot content renders a non-element root (Fragment/multiple roots/text/comment), Vue cannot animate it.");
  lines.push("\nDocs:\nhttps://cn.vuejs.org/guide/built-ins/transition#the-transition-component");
  return lines.join("\n");
}
var VUE_TRANSITION_WARN = "Component inside <Transition> renders non-element root node that cannot be animated.";
function extractComponentName(text) {
  return text.match(/at <([^\s>]+)/)?.[1];
}
function extractRouteKey(text) {
  return text.match(/key=\"([^\"]+)\"/)?.[1];
}
function guessViewFileFromInstance(instance) {
  if (!instance) return void 0;
  return instance.$options["__file"];
}
function getViewUrlFromInstance(instance) {
  if (!instance) return void 0;
  return instance.$el?.baseURI;
}
function alreadyInstalled() {
  return Boolean(globalThis["__VITE_PLUGIN_VUE_TRANSITION_ROOT_VALIDATOR_INSTALLED__"]);
}
function markInstalled() {
  globalThis["__VITE_PLUGIN_VUE_TRANSITION_ROOT_VALIDATOR_INSTALLED__"] = true;
}
var pendingPayloads = /* @__PURE__ */ new Map();
var listenersBound = false;
var retryTimer = null;
var retryDelayMs = 200;
function getHot() {
  return import.meta.hot;
}
function trySendNow(payload) {
  const hot = getHot();
  if (!hot?.send) return false;
  try {
    hot.send("vite-plugin-vue-transition-root-validator:vue-warn", payload);
    return true;
  } catch {
    return false;
  }
}
function scheduleRetry() {
  if (retryTimer !== null) return;
  retryTimer = globalThis.setTimeout(() => {
    retryTimer = null;
    flushPendingPayloads();
    if (pendingPayloads.size) {
      retryDelayMs = Math.min(retryDelayMs * 2, 2e3);
      scheduleRetry();
    }
  }, retryDelayMs);
}
function flushPendingPayloads() {
  if (!pendingPayloads.size) return;
  for (const p of pendingPayloads.values()) trySendNow(p);
}
function bindHmrListenersOnce() {
  if (listenersBound) return;
  listenersBound = true;
  const hot = getHot();
  if (!hot?.on) return;
  hot.on("vite:ws:connect", () => {
    retryDelayMs = 200;
    if (retryTimer !== null) {
      clearTimeout(retryTimer);
      retryTimer = null;
    }
    flushPendingPayloads();
  });
  hot.on("vite-plugin-vue-transition-root-validator:ack", (data) => {
    const key = data?.key;
    if (!key) return;
    pendingPayloads.delete(key);
    if (!pendingPayloads.size) {
      retryDelayMs = 200;
      if (retryTimer !== null) {
        clearTimeout(retryTimer);
        retryTimer = null;
      }
    }
  });
}
function send(payload) {
  if (!getHot()?.send) return;
  bindHmrListenersOnce();
  pendingPayloads.set(payload.key, payload);
  trySendNow(payload);
  scheduleRetry();
}
var originalWarnHandler = null;
function resendLog(msg, instance, trace) {
  if (originalWarnHandler) originalWarnHandler(msg, instance, trace);
}
function setupVueRootValidator(app, options = {}) {
  if (alreadyInstalled()) return;
  markInstalled();
  const lang = options.lang ?? "en";
  const disableAfterFirstError = options.disableAfterFirstError ?? false;
  bindHmrListenersOnce();
  originalWarnHandler = app.config.warnHandler;
  let lastSentAt = 0;
  let lastSentKey = "";
  let errorSent = false;
  app.config.warnHandler = (msg, instance, trace) => {
    resendLog(msg, instance, trace);
    if (disableAfterFirstError && errorSent) return;
    if (!msg.includes(VUE_TRANSITION_WARN)) return;
    const now = Date.now();
    const key = (msg + trace).slice(0, 400);
    if (now - lastSentAt > 500 || key !== lastSentKey) {
      lastSentAt = now;
      lastSentKey = key;
      const routeKey = extractRouteKey(trace);
      const component = extractComponentName(trace);
      const file = guessViewFileFromInstance(instance);
      const message = formatTransitionRootMessage(lang, {
        url: getViewUrlFromInstance(instance),
        file,
        routeKey,
        component
      });
      send({
        key: message.slice(0, 800),
        message,
        lang
      });
      errorSent = true;
    }
  };
}
export {
  setupVueRootValidator
};
//# sourceMappingURL=vite-plugin-vue-transition-root-validator_client.js.map
