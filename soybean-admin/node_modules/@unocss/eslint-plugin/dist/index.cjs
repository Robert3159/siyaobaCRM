Object.defineProperty(exports, '__esModule', { value: true });
//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const require_dirs = require('./dirs-DMLliOn8.cjs');
let node_path = require("node:path");
let _typescript_eslint_utils = require("@typescript-eslint/utils");
let synckit = require("synckit");
let magic_string = require("magic-string");
magic_string = __toESM(magic_string);
let _typescript_eslint_types = require("@typescript-eslint/types");

//#region src/constants.ts
const CLASS_FIELDS = ["class", "classname"];
const AST_NODES_WITH_QUOTES = ["Literal", "VLiteral"];

//#endregion
//#region src/rules/_.ts
const syncAction = (0, synckit.createSyncFn)((0, node_path.join)(require_dirs.distDir, "worker.mjs"));
const createRule = _typescript_eslint_utils.ESLintUtils.RuleCreator(() => "https://unocss.dev/integrations/eslint#rules");

//#endregion
//#region src/rules/order-attributify.ts
const IGNORE_ATTRIBUTES = [
	"style",
	"class",
	"classname",
	"value"
];
var order_attributify_default = createRule({
	name: "order-attributify",
	meta: {
		type: "layout",
		fixable: "code",
		docs: { description: "Order of UnoCSS attributes" },
		messages: { "invalid-order": "UnoCSS attributes are not ordered" },
		schema: []
	},
	defaultOptions: [],
	create(context) {
		const scriptVisitor = {};
		const templateBodyVisitor = { VStartTag(node) {
			var _context$settings$uno;
			const valueless = node.attributes.filter((i) => {
				var _i$key, _i$key2;
				return typeof ((_i$key = i.key) === null || _i$key === void 0 ? void 0 : _i$key.name) === "string" && !IGNORE_ATTRIBUTES.includes((_i$key2 = i.key) === null || _i$key2 === void 0 || (_i$key2 = _i$key2.name) === null || _i$key2 === void 0 ? void 0 : _i$key2.toLowerCase()) && i.value == null;
			});
			if (!valueless.length) return;
			const input = valueless.map((i) => i.key.name).join(" ").trim();
			const sorted = syncAction((_context$settings$uno = context.settings.unocss) === null || _context$settings$uno === void 0 ? void 0 : _context$settings$uno.configPath, "sort", input, context.filename);
			if (sorted !== input) context.report({
				node,
				messageId: "invalid-order",
				fix(fixer) {
					const codeFull = context.getSourceCode();
					const offset = node.range[0];
					const s = new magic_string.default(codeFull.getText().slice(node.range[0], node.range[1]));
					const sortedNodes = valueless.map((i) => [i.range[0] - offset, i.range[1] - offset]).sort((a, b) => b[0] - a[0]);
					for (const [start, end] of sortedNodes.slice(1)) s.remove(start, end);
					s.overwrite(sortedNodes[0][0], sortedNodes[0][1], ` ${sorted.trim()} `);
					return fixer.replaceText(node, s.toString());
				}
			});
		} };
		const parserServices = (context === null || context === void 0 ? void 0 : context.sourceCode.parserServices) || context.parserServices;
		if (parserServices == null || parserServices.defineTemplateBodyVisitor == null) return scriptVisitor;
		else return parserServices === null || parserServices === void 0 ? void 0 : parserServices.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
	}
});

//#endregion
//#region src/rules/blocklist.ts
var blocklist_default = createRule({
	name: "blocklist",
	meta: {
		type: "problem",
		fixable: "code",
		docs: { description: "Utilities in UnoCSS blocklist" },
		messages: { "in-blocklist": "\"{{name}}\" is in blocklist{{reason}}" },
		schema: []
	},
	defaultOptions: [],
	create(context) {
		const checkLiteral = (node) => {
			var _context$settings$uno;
			if (typeof node.value !== "string" || !node.value.trim()) return;
			const input = node.value;
			syncAction((_context$settings$uno = context.settings.unocss) === null || _context$settings$uno === void 0 ? void 0 : _context$settings$uno.configPath, "blocklist", input, context.filename).forEach(([name, meta]) => {
				context.report({
					node,
					messageId: "in-blocklist",
					data: {
						name,
						reason: (meta === null || meta === void 0 ? void 0 : meta.message) ? `: ${meta.message}` : ""
					}
				});
			});
		};
		const scriptVisitor = {
			JSXAttribute(node) {
				if (typeof node.name.name === "string" && CLASS_FIELDS.includes(node.name.name.toLowerCase()) && node.value) {
					if (node.value.type === "Literal") checkLiteral(node.value);
				}
			},
			SvelteAttribute(node) {
				if (node.key.name === "class") {
					var _node$value;
					if (((_node$value = node.value) === null || _node$value === void 0 ? void 0 : _node$value[0].type) === "SvelteLiteral") checkLiteral(node.value[0]);
				}
			}
		};
		const templateBodyVisitor = {
			VAttribute(node) {
				if (node.key.name === "class") {
					if (node.value.type === "VLiteral") checkLiteral(node.value);
				}
			},
			VStartTag(node) {
				const valueless = node.attributes.filter((i) => {
					var _i$key, _i$key2;
					return typeof ((_i$key = i.key) === null || _i$key === void 0 ? void 0 : _i$key.name) === "string" && !IGNORE_ATTRIBUTES.includes((_i$key2 = i.key) === null || _i$key2 === void 0 || (_i$key2 = _i$key2.name) === null || _i$key2 === void 0 ? void 0 : _i$key2.toLowerCase()) && i.value == null;
				});
				if (!valueless.length) return;
				for (const node$1 of valueless) {
					var _node$key, _context$settings$uno2;
					if (!(node$1 === null || node$1 === void 0 || (_node$key = node$1.key) === null || _node$key === void 0 ? void 0 : _node$key.name)) continue;
					syncAction((_context$settings$uno2 = context.settings.unocss) === null || _context$settings$uno2 === void 0 ? void 0 : _context$settings$uno2.configPath, "blocklist", node$1.key.name, context.filename).forEach(([name, meta]) => {
						context.report({
							node: node$1,
							messageId: "in-blocklist",
							data: {
								name,
								reason: (meta === null || meta === void 0 ? void 0 : meta.message) ? `: ${meta.message}` : ""
							}
						});
					});
				}
			}
		};
		const parserServices = (context === null || context === void 0 ? void 0 : context.sourceCode.parserServices) || context.parserServices;
		if (parserServices == null || parserServices.defineTemplateBodyVisitor == null) return scriptVisitor;
		else return parserServices === null || parserServices === void 0 ? void 0 : parserServices.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
	}
});

//#endregion
//#region src/rules/enforce-class-compile.ts
var enforce_class_compile_default = createRule({
	name: "enforce-class-compile",
	meta: {
		type: "problem",
		fixable: "code",
		docs: { description: "Enforce class compilation" },
		messages: { missing: "prefix: `{{prefix}}` is missing" },
		schema: [{
			type: "object",
			properties: {
				prefix: { type: "string" },
				enableFix: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},
	defaultOptions: [{
		prefix: ":uno:",
		enableFix: true
	}],
	create(context, [mergedOptions]) {
		const CLASS_COMPILE_PREFIX = `${mergedOptions.prefix} `;
		const ENABLE_FIX = mergedOptions.enableFix;
		function report({ node, fix }) {
			context.report({
				node,
				loc: node.loc,
				messageId: "missing",
				data: { prefix: CLASS_COMPILE_PREFIX.trim() },
				fix: (...args) => ENABLE_FIX ? fix(...args) : null
			});
		}
		const scriptVisitor = {
			JSXAttribute(_node) {},
			SvelteAttribute(_node) {}
		};
		const reportClassList = (node, classList) => {
			if (classList.startsWith(CLASS_COMPILE_PREFIX)) return;
			report({
				node,
				fix(fixer) {
					return fixer.replaceTextRange([node.range[0] + 1, node.range[1] - 1], `${CLASS_COMPILE_PREFIX}${classList}`);
				}
			});
		};
		const templateBodyVisitor = {
			[`VAttribute[key.name=class]`](attr) {
				const valueNode = attr.value;
				if (!valueNode || !valueNode.value) return;
				reportClassList(valueNode, valueNode.value);
			},
			[`VAttribute[key.argument.name=class] VExpressionContainer Literal:not(ConditionalExpression .test Literal):not(Property .value Literal)`](literal) {
				if (!literal.value || typeof literal.value !== "string") return;
				reportClassList(literal, literal.value);
			},
			[`VAttribute[key.argument.name=class] VExpressionContainer TemplateElement`](templateElement) {
				if (!templateElement.value.raw) return;
				reportClassList(templateElement, templateElement.value.raw);
			},
			[`VAttribute[key.argument.name=class] VExpressionContainer Property`](property) {
				if (property.key.type !== "Identifier") return;
				const classListString = property.key.name;
				if (classListString.startsWith(CLASS_COMPILE_PREFIX)) return;
				report({
					node: property.key,
					fix(fixer) {
						let replacePropertyKeyText = `'${CLASS_COMPILE_PREFIX}${classListString}'`;
						if (property.shorthand) replacePropertyKeyText = `${replacePropertyKeyText}: ${classListString}`;
						return fixer.replaceTextRange(property.key.range, replacePropertyKeyText);
					}
				});
			}
		};
		const parserServices = (context === null || context === void 0 ? void 0 : context.sourceCode.parserServices) || context.parserServices;
		if (parserServices == null || parserServices.defineTemplateBodyVisitor == null) return scriptVisitor;
		else return parserServices === null || parserServices === void 0 ? void 0 : parserServices.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
	}
});

//#endregion
//#region src/rules/order.ts
var order_default = createRule({
	name: "order",
	meta: {
		type: "layout",
		fixable: "code",
		docs: { description: "Order of UnoCSS utilities in class attribute" },
		messages: { "invalid-order": "UnoCSS utilities are not ordered" },
		schema: [{
			type: "object",
			properties: {
				unoFunctions: {
					type: "array",
					items: { type: "string" }
				},
				unoVariables: {
					type: "array",
					items: { type: "string" }
				}
			},
			additionalProperties: false
		}]
	},
	defaultOptions: [{
		unoFunctions: ["clsx", "classnames"],
		unoVariables: ["^cls", "classNames?$"]
	}],
	create(context) {
		let { unoFunctions = ["clsx", "classnames"], unoVariables = ["^cls", "classNames?$"] } = context.options[0] || {};
		unoFunctions = unoFunctions.map((name) => name.toLowerCase());
		function isUnoFunction(name) {
			return unoFunctions.includes(name.toLowerCase());
		}
		const unoVariablesRegexes = unoVariables.map((regex) => new RegExp(regex, "i"));
		function isUnoVariable(name) {
			return unoVariablesRegexes.some((reg) => reg.test(name));
		}
		function checkLiteral(node, addSpace) {
			var _context$settings$uno;
			if (typeof node.value !== "string" || !node.value.trim()) return;
			const input = node.value;
			let sorted = syncAction((_context$settings$uno = context.settings.unocss) === null || _context$settings$uno === void 0 ? void 0 : _context$settings$uno.configPath, "sort", input, context.filename).trim();
			if (addSpace === "before") sorted = ` ${sorted}`;
			else if (addSpace === "after") sorted += " ";
			if (sorted !== input) {
				const nodeOrToken = node.type === "SvelteLiteral" ? {
					type: _typescript_eslint_types.AST_TOKEN_TYPES.String,
					value: node.value,
					loc: node.loc,
					range: node.range
				} : node;
				context.report({
					node: nodeOrToken,
					loc: node.loc,
					messageId: "invalid-order",
					fix(fixer) {
						if (AST_NODES_WITH_QUOTES.includes(node.type)) return fixer.replaceTextRange([node.range[0] + 1, node.range[1] - 1], sorted);
						else return fixer.replaceText(nodeOrToken, sorted);
					}
				});
			}
		}
		function checkTemplateElement(quasi) {
			var _context$settings$uno2;
			const input = quasi.value.raw;
			if (!input) return;
			const getRange = () => {
				const text = context.sourceCode.getText(quasi);
				const raw = quasi.value.raw;
				if (!text.includes(raw)) return;
				const rawStart = text.indexOf(raw);
				const start = quasi.range[0] + rawStart;
				const end = quasi.range[0] + rawStart + raw.length;
				if (start < quasi.range[0] || end > quasi.range[1]) return;
				return [start, end];
			};
			if (!getRange()) return;
			let sorted = syncAction((_context$settings$uno2 = context.settings.unocss) === null || _context$settings$uno2 === void 0 ? void 0 : _context$settings$uno2.configPath, "sort", input, context.filename).trim();
			if (/^\s/.test(input)) sorted = ` ${sorted}`;
			if (/\s$/.test(input)) sorted += " ";
			if (sorted !== input) context.report({
				node: quasi,
				loc: quasi.loc,
				messageId: "invalid-order",
				fix(fixer) {
					const realRange = getRange();
					if (!realRange) return null;
					return fixer.replaceTextRange(realRange, sorted);
				}
			});
		}
		function isPossibleLiteral(node) {
			return node.type === "Literal" || node.type === "TemplateLiteral" || node.type === "TaggedTemplateExpression";
		}
		function checkPossibleLiteral(...nodes) {
			nodes.forEach((node) => {
				if (!isPossibleLiteral(node)) return;
				if (node.type === "Literal" && typeof node.value === "string") return checkLiteral(node);
				const isSimpleTemplateLiteral = (node$1) => {
					return node$1.expressions.length === 0 && node$1.quasis.length === 1;
				};
				if (node.type === "TemplateLiteral" && isSimpleTemplateLiteral(node)) return checkTemplateElement(node.quasis[0]);
				const isStringRaw = (tag) => {
					return tag.type === "MemberExpression" && tag.object.type === "Identifier" && tag.object.name === "String" && tag.property.type === "Identifier" && tag.property.name === "raw";
				};
				if (node.type === "TaggedTemplateExpression" && isStringRaw(node.tag) && isSimpleTemplateLiteral(node.quasi)) return checkTemplateElement(node.quasi.quasis[0]);
				if (node.type === "TemplateLiteral" && node.expressions.length > 0 && node.quasis.length > 0) {
					node.quasis.forEach((quasi) => {
						checkTemplateElement(quasi);
					});
					return;
				}
			});
		}
		const scriptVisitor = {
			JSXAttribute(node) {
				if (typeof node.name.name === "string" && CLASS_FIELDS.includes(node.name.name.toLowerCase()) && node.value) {
					if (isPossibleLiteral(node.value)) return checkPossibleLiteral(node.value);
					else if (node.value.type === "JSXExpressionContainer" && isPossibleLiteral(node.value.expression)) return checkPossibleLiteral(node.value.expression);
				}
			},
			SvelteAttribute(node) {
				if (node.key.name === "class") {
					if (!node.value.length) return;
					function checkExpressionRecursively(expression) {
						if (expression.type !== "ConditionalExpression") return;
						if (expression.consequent.type === "Literal") checkLiteral(expression.consequent);
						if (expression.alternate) {
							if (expression.alternate.type === "ConditionalExpression") checkExpressionRecursively(expression.alternate);
							else if (expression.alternate.type === "Literal") checkLiteral(expression.alternate);
						}
					}
					node.value.forEach((obj, i) => {
						if (obj.type === "SvelteMustacheTag") checkExpressionRecursively(obj.expression);
						else if (obj.type === "SvelteLiteral") {
							var _node$value, _node$value2;
							checkLiteral(obj, ((_node$value = node.value) === null || _node$value === void 0 || (_node$value = _node$value[i - 1]) === null || _node$value === void 0 ? void 0 : _node$value.type) === "SvelteMustacheTag" ? "before" : ((_node$value2 = node.value) === null || _node$value2 === void 0 || (_node$value2 = _node$value2[i + 1]) === null || _node$value2 === void 0 ? void 0 : _node$value2.type) === "SvelteMustacheTag" ? "after" : void 0);
						}
					});
				}
			},
			CallExpression(node) {
				if (!(node.callee.type === "Identifier" && isUnoFunction(node.callee.name))) return;
				node.arguments.forEach((arg) => {
					if (isPossibleLiteral(arg)) return checkPossibleLiteral(arg);
					if (arg.type === "ConditionalExpression") return checkPossibleLiteral(arg.consequent, arg.alternate);
					if (arg.type === "LogicalExpression") return checkPossibleLiteral(arg.left, arg.right);
					function handleObjectExpression(node$1) {
						node$1.properties.forEach((p) => {
							if (p.type !== "Property") return;
							if (isPossibleLiteral(p.value)) return checkPossibleLiteral(p.value);
							if (p.value.type === "ObjectExpression") return handleObjectExpression(p.value);
						});
						return checkPossibleLiteral(...node$1.properties.filter((p) => p.type === "Property").map((p) => p.key));
					}
					if (arg.type === "ObjectExpression") return handleObjectExpression(arg);
					if (arg.type === "ArrayExpression") return arg.elements.forEach((element) => {
						if (element && isPossibleLiteral(element)) return checkPossibleLiteral(element);
					});
				});
			},
			VariableDeclarator(node) {
				if (node.id.type !== "Identifier" || !node.init || !isUnoVariable(node.id.name)) return;
				if (isPossibleLiteral(node.init)) return checkPossibleLiteral(node.init);
				if (node.init.type === "TSAsExpression" && isPossibleLiteral(node.init.expression)) return checkPossibleLiteral(node.init.expression);
				function handleObjectExpression(node$1) {
					node$1.properties.forEach((p) => {
						if (p.type !== "Property") return;
						if (isPossibleLiteral(p.value)) return checkPossibleLiteral(p.value);
						if (p.value.type === "ObjectExpression") return handleObjectExpression(p.value);
					});
				}
				if (node.init.type === "ObjectExpression") return handleObjectExpression(node.init);
				if (node.init.type === "TSAsExpression" && node.init.expression.type === "ObjectExpression") return handleObjectExpression(node.init.expression);
			}
		};
		const templateBodyVisitor = { VAttribute(node) {
			if (node.key.name === "class") {
				if (node.value.type === "VLiteral") checkLiteral(node.value);
			}
		} };
		const parserServices = (context === null || context === void 0 ? void 0 : context.sourceCode.parserServices) || context.parserServices;
		if (parserServices == null || parserServices.defineTemplateBodyVisitor == null) return scriptVisitor;
		else return parserServices === null || parserServices === void 0 ? void 0 : parserServices.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
	}
});

//#endregion
//#region src/plugin.ts
const plugin = { rules: {
	order: order_default,
	"order-attributify": order_attributify_default,
	blocklist: blocklist_default,
	"enforce-class-compile": enforce_class_compile_default
} };

//#endregion
//#region src/configs/flat.ts
var flat_default = {
	plugins: { unocss: plugin },
	rules: {
		"unocss/order": "warn",
		"unocss/order-attributify": "warn"
	}
};

//#endregion
//#region src/configs/recommended.ts
var recommended_default = {
	plugins: ["@unocss"],
	rules: {
		"@unocss/order": "warn",
		"@unocss/order-attributify": "warn"
	}
};

//#endregion
//#region src/index.ts
const configs = {
	recommended: recommended_default,
	flat: flat_default
};
var src_default = {
	...plugin,
	configs
};

//#endregion
exports.__toESM = __toESM;
exports.configs = configs;
exports.default = src_default;