//#region src/i18n.ts
function formatTransitionRootMessage(lang, ctx) {
	if (lang === "zh") {
		const title$1 = "Vue <Transition> 要求插槽内容具有单一的“元素根节点”。";
		const lines$1 = [];
		lines$1.push(title$1);
		if (ctx.file) lines$1.push(`\n文件: ${ctx.file}`);
		if (ctx.url) lines$1.push(`URL: ${ctx.url}`);
		const meta$1 = [];
		if (ctx.component) meta$1.push(`component=${ctx.component}`);
		if (ctx.routeKey) meta$1.push(`key=${ctx.routeKey}`);
		if (meta$1.length) lines$1.push(`上下文: ${meta$1.join(" ")}`);
		lines$1.push(`
如何修复:
- 在${ctx.file ? `文件 ${ctx.file}` : "该组件"}的 <template> 最外层添加一个容器标签（如 <div> / <main>），把所有内容包起来，确保最终只渲染出一个根“标签元素”。\n- 根节点不能是多个并列元素（Fragment/多根），也不能是纯文本或注释。
- 如果根部使用了 v-if / v-else，确保每个分支都只渲染一个根标签元素。`);
		lines$1.push("\n为什么会这样:\nVue 的 <Transition> 需要把过渡 class 应用在一个真实的 DOM 元素上；当插槽内容渲染出的根节点不是“单一元素”（例如 Fragment、多根、纯文本或注释）时，就无法执行进入/离开过渡。");
		lines$1.push("\n相关文档:\nhttps://cn.vuejs.org/guide/built-ins/transition#the-transition-component");
		return lines$1.join("\n");
	}
	const title = "Vue <Transition> requires a single element root node in its slot.";
	const lines = [];
	lines.push(title);
	if (ctx.file) lines.push(`\nFile: ${ctx.file}`);
	if (ctx.url) lines.push(`URL: ${ctx.url}`);
	const meta = [];
	if (ctx.component) meta.push(`component=${ctx.component}`);
	if (ctx.routeKey) meta.push(`key=${ctx.routeKey}`);
	if (meta.length) lines.push(`Context: ${meta.join(" ")}`);
	lines.push(`
How to fix:
- In the <template> of ${ctx.file ? `file ${ctx.file}` : "this component"}, wrap everything with a single container element (e.g. <div> / <main>), so the final render has exactly one root *element*.\n- The root cannot be a Fragment (multiple siblings), plain text, or a comment.
- If you use v-if / v-else at the root, ensure each branch renders exactly one root element.`);
	lines.push("\nWhy this happens:\nVue <Transition> needs to apply transition classes to a real DOM element. If the slot content renders a non-element root (Fragment/multiple roots/text/comment), Vue cannot animate it.");
	lines.push("\nDocs:\nhttps://cn.vuejs.org/guide/built-ins/transition#the-transition-component");
	return lines.join("\n");
}

//#endregion
//#region src/client.ts
/**
* Vue Transition 警告关键字
* 用于识别 Vue 运行时发出的 Transition 多根节点警告
*/
const VUE_TRANSITION_WARN = "Component inside <Transition> renders non-element root node that cannot be animated.";
/**
* 从 Vue 警告信息中提取组件名称
* 示例: "at <Index onVnodeUnmounted=... key="/test" ... >"
*/
function extractComponentName(text) {
	return text.match(/at <([^\s>]+)/)?.[1];
}
/**
* 从 Vue 警告信息中提取路由 key
* 示例: key="/test"
*/
function extractRouteKey(text) {
	return text.match(/key=\"([^\"]+)\"/)?.[1];
}
/**
* 获取组件实例可能对应的文件路径
*/
function guessViewFileFromInstance(instance) {
	if (!instance) return void 0;
	return instance.$options["__file"];
}
/**
* 获取组件实例可能对应的文件路径
*/
function getViewUrlFromInstance(instance) {
	if (!instance) return void 0;
	return instance.$el?.baseURI;
}
/**
* 检查插件是否已经安装
*/
function alreadyInstalled() {
	return Boolean(globalThis["__VITE_PLUGIN_VUE_TRANSITION_ROOT_VALIDATOR_INSTALLED__"]);
}
/**
* 标记插件已安装
*/
function markInstalled() {
	globalThis["__VITE_PLUGIN_VUE_TRANSITION_ROOT_VALIDATOR_INSTALLED__"] = true;
}
const pendingPayloads = /* @__PURE__ */ new Map();
let listenersBound = false;
let retryTimer = null;
let retryDelayMs = 200;
function getHot() {
	return import.meta.hot;
}
function trySendNow(payload) {
	const hot = getHot();
	if (!hot?.send) return false;
	try {
		hot.send("vite-plugin-vue-transition-root-validator:vue-warn", payload);
		return true;
	} catch {
		return false;
	}
}
function scheduleRetry() {
	if (retryTimer !== null) return;
	retryTimer = globalThis.setTimeout(() => {
		retryTimer = null;
		flushPendingPayloads();
		if (pendingPayloads.size) {
			retryDelayMs = Math.min(retryDelayMs * 2, 2e3);
			scheduleRetry();
		}
	}, retryDelayMs);
}
function flushPendingPayloads() {
	if (!pendingPayloads.size) return;
	for (const p of pendingPayloads.values()) trySendNow(p);
}
function bindHmrListenersOnce() {
	if (listenersBound) return;
	listenersBound = true;
	const hot = getHot();
	if (!hot?.on) return;
	hot.on("vite:ws:connect", () => {
		retryDelayMs = 200;
		if (retryTimer !== null) {
			clearTimeout(retryTimer);
			retryTimer = null;
		}
		flushPendingPayloads();
	});
	hot.on("vite-plugin-vue-transition-root-validator:ack", (data) => {
		const key = data?.key;
		if (!key) return;
		pendingPayloads.delete(key);
		if (!pendingPayloads.size) {
			retryDelayMs = 200;
			if (retryTimer !== null) {
				clearTimeout(retryTimer);
				retryTimer = null;
			}
		}
	});
}
function send(payload) {
	if (!getHot()?.send) return;
	bindHmrListenersOnce();
	pendingPayloads.set(payload.key, payload);
	trySendNow(payload);
	scheduleRetry();
}
let originalWarnHandler = null;
function resendLog(msg, instance, trace) {
	if (originalWarnHandler) originalWarnHandler(msg, instance, trace);
}
/**
* 设置 Vue Root Validator
*
* 在 Vue 应用上注册 warnHandler 来捕获 Transition 多根节点警告
*
* @param app - Vue 应用实例
* @param options - 配置选项
*
* @example
* ```ts
* import { createApp } from 'vue';
* import { setupVueRootValidator } from 'virtual:vue-transition-root-validator';
* import App from './App.vue';
*
* const app = createApp(App);
*
* // 在挂载前设置验证器
* setupVueRootValidator(app, { lang: 'zh' });
*
* app.mount('#app');
* ```
*/
function setupVueRootValidator(app, options = {}) {
	if (alreadyInstalled()) return;
	markInstalled();
	const lang = options.lang ?? "en";
	const disableAfterFirstError = options.disableAfterFirstError ?? false;
	bindHmrListenersOnce();
	originalWarnHandler = app.config.warnHandler;
	let lastSentAt = 0;
	let lastSentKey = "";
	let errorSent = false;
	/**
	* 自定义 Vue 警告处理器
	*
	* @param msg - 警告消息
	* @param instance - 组件实例
	* @param trace - 组件追踪栈
	*/
	app.config.warnHandler = (msg, instance, trace) => {
		resendLog(msg, instance, trace);
		if (disableAfterFirstError && errorSent) return;
		if (!msg.includes(VUE_TRANSITION_WARN)) return;
		const now = Date.now();
		const key = (msg + trace).slice(0, 400);
		if (now - lastSentAt > 500 || key !== lastSentKey) {
			lastSentAt = now;
			lastSentKey = key;
			const routeKey = extractRouteKey(trace);
			const component = extractComponentName(trace);
			const file = guessViewFileFromInstance(instance);
			const message = formatTransitionRootMessage(lang, {
				url: getViewUrlFromInstance(instance),
				file,
				routeKey,
				component
			});
			send({
				key: message.slice(0, 800),
				message,
				lang
			});
			errorSent = true;
		}
	};
}

//#endregion
export { setupVueRootValidator };
//# sourceMappingURL=client.js.map