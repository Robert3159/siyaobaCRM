import { dirname } from "node:path";
import process from "node:process";
import { collapseVariantGroup, createGenerator, notNull, parseVariantGroup } from "@unocss/core";
import { loadConfig } from "@unocss/config";
import { runAsWorker } from "synckit";

//#region ../../virtual-shared/integration/src/sort-rules.ts
async function sortRules(rules, uno) {
	const unknown = [];
	if (!uno.config.details) uno.config.details = true;
	const expandedResult = parseVariantGroup(rules);
	rules = expandedResult.expanded;
	const result = [];
	const arr = rules.split(/\s+/g);
	for (const i of arr) {
		var _token$0$;
		if (!i) continue;
		const token = await uno.parseToken(i);
		if (token == null) {
			unknown.push(i);
			result.push(void 0);
			continue;
		}
		const variantRank = (((_token$0$ = token[0][5]) === null || _token$0$ === void 0 || (_token$0$ = _token$0$.variantHandlers) === null || _token$0$ === void 0 ? void 0 : _token$0$.length) || 0) * 1e5;
		const order = token[0][0] + variantRank;
		result.push([order, i]);
	}
	let sorted = result.filter(notNull).sort((a, b) => {
		let result$1 = a[0] - b[0];
		if (result$1 === 0) result$1 = a[1].localeCompare(b[1]);
		return result$1;
	}).map((i) => i[1]).join(" ");
	if (expandedResult === null || expandedResult === void 0 ? void 0 : expandedResult.prefixes.length) sorted = collapseVariantGroup(sorted, expandedResult.prefixes);
	return [...unknown, sorted].join(" ").trim();
}

//#endregion
//#region src/worker.ts
var _process$env;
const promises = /* @__PURE__ */ new Map();
(_process$env = process.env).ESLINT || (_process$env.ESLINT = "true");
function getSearchCwd(id) {
	if (id.match(/\.\w+\/[^/]+$/)) return dirname(id.slice(0, id.lastIndexOf("/")));
	return dirname(id);
}
async function _getGenerator(configPath, id) {
	const { config, sources } = await loadConfig(configPath ? process.cwd() : id ? getSearchCwd(id) : process.cwd(), configPath);
	if (!sources.length) throw new Error("[@unocss/eslint-plugin] No config file found, create a `uno.config.ts` file in your project root and try again.");
	return createGenerator({
		...config,
		warn: false
	});
}
function getCacheKey(configPath, id) {
	if (configPath) return `config:${configPath}`;
	if (id) return `dir:${getSearchCwd(id)}`;
	return `cwd:${process.cwd()}`;
}
async function getGenerator(configPath, id) {
	const cacheKey = getCacheKey(configPath, id);
	let promise = promises.get(cacheKey);
	if (!promise) {
		promise = _getGenerator(configPath, id);
		promises.set(cacheKey, promise);
	}
	return await promise;
}
function setGenerator(generator, configPath) {
	const cacheKey = configPath ? `config:${configPath}` : `cwd:${process.cwd()}`;
	promises.set(cacheKey, Promise.resolve(generator));
}
async function actionSort(configPath, classes, id) {
	return await sortRules(classes, await getGenerator(configPath, id));
}
async function actionBlocklist(configPath, classes, id) {
	const uno = await getGenerator(configPath, id);
	const blocked = /* @__PURE__ */ new Map();
	const values = [...(await uno.applyExtractors(classes, id)).values()];
	const getMeta = (raw, meta) => {
		return (meta === null || meta === void 0 ? void 0 : meta.message) ? {
			...meta,
			message: typeof meta.message === "function" ? meta.message(raw) : meta.message
		} : meta;
	};
	const matchBlocked = async (raw) => {
		if (blocked.has(raw)) return;
		const rule = uno.getBlocked(raw);
		if (rule) {
			blocked.set(raw, getMeta(raw, rule[1]));
			return;
		}
		let current = raw;
		for (const p of uno.config.preprocess) current = p(raw);
		const rules = (await uno.matchVariants(raw, current)).map((r) => r && uno.getBlocked(r[1]));
		for (const rule$1 of rules) if (rule$1) blocked.set(raw, getMeta(raw, rule$1[1]));
	};
	await Promise.all(values.map(matchBlocked));
	return [...blocked];
}
async function runAsync(configPath, action, ...args) {
	switch (action) {
		case "sort": return actionSort(configPath, ...args);
		case "blocklist": return actionBlocklist(configPath, ...args);
	}
}
function run(configPath, action, ...args) {
	return runAsync(configPath, action, ...args);
}
runAsWorker(run);

//#endregion
export { getGenerator, run, runAsync, setGenerator };